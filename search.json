[{"title":"TCP protocol","date":"2021-10-12T01:20:23.000Z","url":"/2021/10/12/TCP-protocol/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["undefined",""]],"content":"一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。 一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。通过==三次握手建立一个链接==，通过==四次挥手来关闭一个连接==。 当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。 序号：seq序号，占32位，用来标识从TCP==源端==向==目的端==发送的==字节流==，发起方发送数据时对此进行标记。 确认序号：==ack序号==，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： ==ACK==：确认序号有效。 ACK和ack不一样 确认方ack=发起方seq+1，两端配对 FIN：释放一个连接。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 三次握手三次握手的本质是确认通信双方收发数据的能力 首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。 于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。 然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。 第一次握手：客户端要向服务端发起连接请求，首先客户端==随机生成==一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号==seq=100==。 第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的==起始序列号100存起来==，并且==随机生成一个服务端的起始序列号==(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。 第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将==服务端的序列号300给存下来==。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、==seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，==需要注意的是==不携带数据的ACK报文是不占据序列号的==，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。 四次挥手四次挥手的目的是关闭一个连接 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是==客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据==；==另外FIN报文段即使不携带数据也要占据一个序列号。== 第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。==此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。== 第三次挥手：服务端将最后数据(比如50个字节)==发送完毕后就向客户端发出连接释放报文==，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。 第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。==注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接==。==而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。== "},{"title":"数据结构-左式堆","date":"2021-10-11T06:21:27.000Z","url":"/2021/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B7%A6%E5%BC%8F%E5%A0%86/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":"背景对于一个二叉堆来说，其建立复杂度O(n)，合并也需要O(n)复杂度(两个堆重建)，而左式堆是为了让两个堆重建的复杂度下降为O(lgn)。 性质零路径长 NPL零路径长：从节点X到一个没有两个子节点的（有一个子节点或没有子节点）节点的最短距离 ; 有一个子节点或没有子节点的节点; 左式堆满足任意节点 的堆 左式堆数量关系xxx 操作 插入：左式堆与单节点左式堆合并 删除最小元素(弹出)：原左式堆左右子树合并 合并：任意两个左式堆合并，复杂度为O(lgn) 合并 当输入的两个堆都是空的，输出空堆；当有一个堆是空的，则返回非空的堆 当两个堆非空时，比较两个根节点的大小，返回为： 堆根节点为原较小的根节点 左子树为原较小的跟节点的左子树 右子树为根节点较大的堆和跟节点较小堆右子树合并的结果 递归操作，设H1的根节点小于H2的根节点，那么令代表H1左子树，代表H1右子树。 ​ H1_root ​ / \\ 如果和的NPL不满足左大于右 则翻转和 代码实现"},{"title":"C++Primer-Ch3","date":"2021-10-11T01:19:20.000Z","url":"/2021/10/11/C-Primer-Ch3/","categories":[["undefined",""]],"content":"命名空间的 using 声明 头文件不应该包含 using 声明 stringstring的操作 使用 getline() 读取一整行如果希望能在最终得到的字符串中保留输入的空白符，需要用getline()。 getline()的参数是一个输入流和一个string对象。 string::size_type 类型s.size() 返回的是 size_type 类型，这是一个无符号数 因此如果 s.size() 和 有符号数n 比较 n是个负数，那么n会自动转为无符号数，将比s.size()大 如果一条表达式中有size()函数就不要再使用int，可以避免混用int和unsigned_int string加法字符串字面值 “xxxx” 字符串字面值和string不是一种类型！！！ string单字符判断在cctype头文件中可以检测一个字符的属性 如是否为数字，是否为小写，是否为空白，是否为标点符号…… 循环string每个字符 迭代器 itreator但凡是使用了迭代器的循环体，都不要向循环体容器中添加元素 数组 "},{"title":"C++Primer-Ch2","date":"2021-10-08T14:43:19.000Z","url":"/2021/10/08/C-Primer-Ch2/","tags":[["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"变量列表初始化int a = 0; int a = {0}; int a{0}; int a(0); int a{0} 与 int a(0) 的区别在于，花括号会进行丢失信息检验，可能丢失信息则报错 e.g. long double b = 3.1415936; ​ int a{b}; //报错 ​ int a(b); //不报错，但丢失信息 复合类型引用 不能定义引用的引用 指针 空指针最好使用 nullptr 来定义 why different? 因为C++中不能将void 类型的指针*隐式转换成其他指针类型 而整型字面量0可以隐式转换成任意类型的空指针常量 而 nullptr 并非整型类别，甚至也不是指针类型，但是==能转换成任意指针类型==。nullptr的实际类型是std:nullptr_t。 建议初始化所有的指针，要么定义了对象后再定义指针指向 要么置为 nullptr void* 可以存放任意类型的指针，即单纯指向一个地址的指针（不知道类型） 复合类型的声明 指向指针的引用 面对一条复杂的指针或引用声明时应从右往左阅读。 即先&amp;（最直接影响，代表是引用） 后int *（表明引用的类型） constconst仅被设置成在文件内有效 如果想要在其他文件中也用 const 声明的量，需要加 extern（声明和定义都要加） 顶层constconstexpr和常量表达式 constexpr 类型，用来检验是不是常量表达式 处理类型类型别名 别名声明 头文件 为了防止头文件被多次包含 头文件保护符应该一直记得加上 术语表 alias 别名 escape sequence 转义序列 : \\x , … header guard 头文件保护符 in scope 在作用域内 literal 字面值 local scope 局部作用域 "},{"title":"C++Primer-Ch1","date":"2021-10-08T14:20:39.000Z","url":"/2021/10/08/C-Primer-Ch1/","tags":[["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"输入输出输入输出库iostream 库，包含 istream 输入流和 ostream 输出流。 cin是istream的一个对象 cout(标准输出)，cerr(错误信息)，clog(一般性信息)是ostream的对象 endl 可以结束当前行,并将缓冲区(buffer)中的内容刷到设备中 要及时刷新缓冲区，防止调试时有待输出信息停留在buffer中 读取数量不定的输入数据 当遇到EOF，或者无效输入(如类型不匹配)，istream对象条件会变为false。 Windows : Ctrl + Z -&gt; Enter Unix : Ctrl + D 术语表 assignment 赋值 buffer 缓冲区 comment 注释 curly brace 花括号 parameter 参数 A parameter is a variable in a method definition. argument 实参 Arguments are the data you pass into the method’s parameters. "}]