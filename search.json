[{"title":"数据结构-左式堆","date":"2021-10-11T06:21:27.000Z","url":"/2021/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B7%A6%E5%BC%8F%E5%A0%86/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":"背景对于一个二叉堆来说，其建立复杂度O(n)，合并也需要O(n)复杂度(两个堆重建)，而左式堆是为了让两个堆重建的复杂度下降为O(lgn)。 性质零路径长 NPL零路径长：从节点X到一个没有两个子节点的（有一个子节点或没有子节点）节点的最短距离 ; 有一个子节点或没有子节点的节点; 左式堆满足任意节点 的堆 左式堆数量关系xxx 操作 插入：左式堆与单节点左式堆合并 删除最小元素(弹出)：原左式堆左右子树合并 合并：任意两个左式堆合并，复杂度为O(lgn) 合并 当输入的两个堆都是空的，输出空堆；当有一个堆是空的，则返回非空的堆 当两个堆非空时，比较两个根节点的大小，返回为： 堆根节点为原较小的根节点 左子树为原较小的跟节点的左子树 右子树为根节点较大的堆和跟节点较小堆右子树合并的结果 递归操作，设H1的根节点小于H2的根节点，那么令代表H1左子树，代表H1右子树。 ​ H1_root ​ / \\ 如果和的NPL不满足左大于右 则翻转和 代码实现"},{"title":"C++Primer-Ch3","date":"2021-10-11T01:19:20.000Z","url":"/2021/10/11/C-Primer-Ch3/","categories":[["undefined",""]],"content":"命名空间的 using 声明 头文件不应该包含 using 声明 stringstring的操作 使用 getline() 读取一整行如果希望能在最终得到的字符串中保留输入的空白符，需要用getline()。 getline()的参数是一个输入流和一个string对象。 string::size_type 类型s.size() 返回的是 size_type 类型，这是一个无符号数 因此如果 s.size() 和 有符号数n 比较 n是个负数，那么n会自动转为无符号数，将比s.size()大 如果一条表达式中有size()函数就不要再使用int，可以避免混用int和unsigned_int string加法字符串字面值 “xxxx” 字符串字面值和string不是一种类型！！！ string单字符判断在cctype头文件中可以检测一个字符的属性 如是否为数字，是否为小写，是否为空白，是否为标点符号…… 循环string每个字符 迭代器 itreator但凡是使用了迭代器的循环体，都不要向循环体容器中添加元素 数组 "},{"title":"C++Primer-Ch2","date":"2021-10-08T14:43:19.000Z","url":"/2021/10/08/C-Primer-Ch2/","tags":[["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"变量列表初始化int a = 0; int a = {0}; int a{0}; int a(0); int a{0} 与 int a(0) 的区别在于，花括号会进行丢失信息检验，可能丢失信息则报错 e.g. long double b = 3.1415936; ​ int a{b}; //报错 ​ int a(b); //不报错，但丢失信息 复合类型引用 不能定义引用的引用 指针 空指针最好使用 nullptr 来定义 why different? 因为C++中不能将void 类型的指针*隐式转换成其他指针类型 而整型字面量0可以隐式转换成任意类型的空指针常量 而 nullptr 并非整型类别，甚至也不是指针类型，但是==能转换成任意指针类型==。nullptr的实际类型是std:nullptr_t。 建议初始化所有的指针，要么定义了对象后再定义指针指向 要么置为 nullptr void* 可以存放任意类型的指针，即单纯指向一个地址的指针（不知道类型） 复合类型的声明 指向指针的引用 面对一条复杂的指针或引用声明时应从右往左阅读。 即先&amp;（最直接影响，代表是引用） 后int *（表明引用的类型） constconst仅被设置成在文件内有效 如果想要在其他文件中也用 const 声明的量，需要加 extern（声明和定义都要加） 顶层constconstexpr和常量表达式 constexpr 类型，用来检验是不是常量表达式 处理类型类型别名 别名声明 头文件 为了防止头文件被多次包含 头文件保护符应该一直记得加上 术语表 alias 别名 escape sequence 转义序列 : \\x , … header guard 头文件保护符 in scope 在作用域内 literal 字面值 local scope 局部作用域 "},{"title":"C++Primer-Ch1","date":"2021-10-08T14:20:39.000Z","url":"/2021/10/08/C-Primer-Ch1/","tags":[["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"输入输出输入输出库iostream 库，包含 istream 输入流和 ostream 输出流。 cin是istream的一个对象 cout(标准输出)，cerr(错误信息)，clog(一般性信息)是ostream的对象 endl 可以结束当前行,并将缓冲区(buffer)中的内容刷到设备中 要及时刷新缓冲区，防止调试时有待输出信息停留在buffer中 读取数量不定的输入数据 当遇到EOF，或者无效输入(如类型不匹配)，istream对象条件会变为false。 Windows : Ctrl + Z -&gt; Enter Unix : Ctrl + D 术语表 assignment 赋值 buffer 缓冲区 comment 注释 curly brace 花括号 parameter 参数 A parameter is a variable in a method definition. argument 实参 Arguments are the data you pass into the method’s parameters. "}]