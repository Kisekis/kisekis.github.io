[{"title":"C++面向对象高级编程","date":"2021-10-23T07:24:10.000Z","url":"/2021/10/23/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/","tags":[["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"Classes 两个分类 Class without pointer member(s) complex(复数) Class with pointer member(s) string Header中的防护式声明 防止重复引用 构造函数 单例模式构造函数放在private区，只能创建一个对象 析构函数不带指针的class多半不用析构函数 参数传递 pass by value or reference(to const)尽量 pass by reference reference pointer 如果不想被修改,加const修饰 参数返回 return by value or reference(to const)尽量 return by reference 什么时候不能返回引用：如果函数内部新创建的变量要返回，就不能返回引用，应该返回指针，否则随着函数结束变量就会消亡 如果得到的变量只是在原有空间上修改就可以返回引用 friend 友元friend可以修饰函数，类 相同class的各个objects互为友元 操作符重载"},{"title":"数据结构-图","date":"2021-10-13T06:09:09.000Z","url":"/2021/10/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":"Graph BasicsNode Edge Class Graph TraversalsDepth-First Search直观含义尽量往前走，无路可走就往回走，换方向继续向前走 应用 拓扑排序 强连通子图 算法 每个可达顶点都将经历 undiscovered，discovered，finished 三个状态 Breadth-First Search直观含义按距离搜索，先遍历 d = 1 的节点，然后 d = 2，… 最先遍历的一定是距离最近的节点 算法 性质如果图是无限的，如果 t 可以从初始顶点 s 到达，那么BFS肯定能找到这个节点 例如一阶逻辑，把公式看作图的顶点 如果s可以推导出t，广度优先搜索t，找到t说明t可证明 Graph representation 邻接表 每个节点记录一个链表，链起每个指向的节点 是一个Array of lists : adj[] 邻接矩阵 adj[i][j] != 0 则有边，记录的值为权重 如果是无向图 则adj[i][j] = adj[j][i] Reachable 图顶点的可达性Q: 给定一个图G，和其中一顶点 u ，问哪些顶点是 u 可达的 闭包形式的定义 初始值 {u} ，因为 u 本身是可达的 增量 ： 如果 v 可达， 且 ，则 w 可达 "},{"title":"LeetCode-整数转罗马数字","date":"2021-10-12T15:15:20.000Z","url":"/2021/10/12/LeetCode-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/","tags":[["LeetCode","/tags/LeetCode/"]],"categories":[["undefined",""]],"content":" 注意这样的写法 pair const auto &amp;[value, symbol] : valueSymbols 遍历"},{"title":"数据结构-堆","date":"2021-10-12T12:39:11.000Z","url":"/2021/10/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":"简介堆就是用数组实现的完全二叉树，没有使用指针 堆的常用方法 构建优先队列：可以弹出根节点，也就是最大/最小的节点 支持堆排序 快速找出一个集合中的最值 性质分类最大堆和最小堆，最大堆的根是最大值，最小堆的跟是最小值 如图是一个最大堆 方法和复杂度 堆的构建 O(n) 搜索堆的元素 O(n) 堆不是为了优化搜索而建立的，所以find()复杂度高 弹出最值 O(logn) 获得最值 Peek() O(1) 堆排序 O(nlogn) "},{"title":"TCP protocol","date":"2021-10-12T01:20:23.000Z","url":"/2021/10/12/TCP-protocol/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["undefined",""]],"content":"一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。 一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。通过==三次握手建立一个链接==，通过==四次挥手来关闭一个连接==。 当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。 序号：seq序号，占32位，用来标识从TCP==源端==向==目的端==发送的==字节流==，发起方发送数据时对此进行标记。 确认序号：==ack序号==，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： ==ACK==：确认序号有效。 ACK和ack不一样 确认方ack=发起方seq+1，两端配对 FIN：释放一个连接。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 三次握手三次握手的本质是确认通信双方收发数据的能力 首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。 于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。 然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。 第一次握手：客户端要向服务端发起连接请求，首先客户端==随机生成==一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号==seq=100==。 第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的==起始序列号100存起来==，并且==随机生成一个服务端的起始序列号==(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。 第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将==服务端的序列号300给存下来==。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、==seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，==需要注意的是==不携带数据的ACK报文是不占据序列号的==，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。 四次挥手四次挥手的目的是关闭一个连接 比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是==客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据==；==另外FIN报文段即使不携带数据也要占据一个序列号。== 第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。==此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。== 第三次挥手：服务端将最后数据(比如50个字节)==发送完毕后就向客户端发出连接释放报文==，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。 第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。==注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接==。==而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。== "},{"title":"数据结构-左式堆","date":"2021-10-11T06:21:27.000Z","url":"/2021/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B7%A6%E5%BC%8F%E5%A0%86/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":"背景对于一个二叉堆来说，其建立复杂度O(n)，合并也需要O(n)复杂度(两个堆重建)，而左式堆是为了让两个堆重建的复杂度下降为O(lgn)。 性质零路径长 NPL零路径长：从节点X到一个没有两个子节点的（有一个子节点或没有子节点）节点的最短距离 ; 有一个子节点或没有子节点的节点; 左式堆满足任意节点 的堆 左式堆数量关系xxx 操作 插入：左式堆与单节点左式堆合并 删除最小元素(弹出)：原左式堆左右子树合并 合并：任意两个左式堆合并，复杂度为O(lgn) 合并 当输入的两个堆都是空的，输出空堆；当有一个堆是空的，则返回非空的堆 当两个堆非空时，比较两个根节点的大小，返回为： 堆根节点为原较小的根节点 左子树为原较小的跟节点的左子树 右子树为根节点较大的堆和跟节点较小堆右子树合并的结果 递归操作，设H1的根节点小于H2的根节点，那么令代表H1左子树，代表H1右子树。 ​ H1_root ​ / \\ 如果和的NPL不满足左大于右 则翻转和 代码实现"},{"title":"C++Primer-Ch3","date":"2021-10-11T01:19:20.000Z","url":"/2021/10/11/C-Primer-Ch3/","categories":[["undefined",""]],"content":"命名空间的 using 声明 头文件不应该包含 using 声明 stringstring的操作 使用 getline() 读取一整行如果希望能在最终得到的字符串中保留输入的空白符，需要用getline()。 getline()的参数是一个输入流和一个string对象。 string::size_type 类型s.size() 返回的是 size_type 类型，这是一个无符号数 因此如果 s.size() 和 有符号数n 比较 n是个负数，那么n会自动转为无符号数，将比s.size()大 如果一条表达式中有size()函数就不要再使用int，可以避免混用int和unsigned_int string加法字符串字面值 “xxxx” 字符串字面值和string不是一种类型！！！ string单字符判断在cctype头文件中可以检测一个字符的属性 如是否为数字，是否为小写，是否为空白，是否为标点符号…… 循环string每个字符 迭代器 itreator但凡是使用了迭代器的循环体，都不要向循环体容器中添加元素 数组 "},{"title":"C++Primer-Ch2","date":"2021-10-08T14:43:19.000Z","url":"/2021/10/08/C-Primer-Ch2/","tags":[["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"变量列表初始化int a = 0; int a = {0}; int a{0}; int a(0); int a{0} 与 int a(0) 的区别在于，花括号会进行丢失信息检验，可能丢失信息则报错 e.g. long double b = 3.1415936; ​ int a{b}; //报错 ​ int a(b); //不报错，但丢失信息 复合类型引用 不能定义引用的引用 指针 空指针最好使用 nullptr 来定义 why different? 因为C++中不能将void 类型的指针*隐式转换成其他指针类型 而整型字面量0可以隐式转换成任意类型的空指针常量 而 nullptr 并非整型类别，甚至也不是指针类型，但是==能转换成任意指针类型==。nullptr的实际类型是std:nullptr_t。 建议初始化所有的指针，要么定义了对象后再定义指针指向 要么置为 nullptr void* 可以存放任意类型的指针，即单纯指向一个地址的指针（不知道类型） 复合类型的声明 指向指针的引用 面对一条复杂的指针或引用声明时应从右往左阅读。 即先&amp;（最直接影响，代表是引用） 后int *（表明引用的类型） constconst仅被设置成在文件内有效 如果想要在其他文件中也用 const 声明的量，需要加 extern（声明和定义都要加） 顶层constconstexpr和常量表达式 constexpr 类型，用来检验是不是常量表达式 处理类型类型别名 别名声明 头文件 为了防止头文件被多次包含 头文件保护符应该一直记得加上 术语表 alias 别名 escape sequence 转义序列 : \\x , … header guard 头文件保护符 in scope 在作用域内 literal 字面值 local scope 局部作用域 "},{"title":"C++Primer-Ch1","date":"2021-10-08T14:20:39.000Z","url":"/2021/10/08/C-Primer-Ch1/","tags":[["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"输入输出输入输出库iostream 库，包含 istream 输入流和 ostream 输出流。 cin是istream的一个对象 cout(标准输出)，cerr(错误信息)，clog(一般性信息)是ostream的对象 endl 可以结束当前行,并将缓冲区(buffer)中的内容刷到设备中 要及时刷新缓冲区，防止调试时有待输出信息停留在buffer中 读取数量不定的输入数据 当遇到EOF，或者无效输入(如类型不匹配)，istream对象条件会变为false。 Windows : Ctrl + Z -&gt; Enter Unix : Ctrl + D 术语表 assignment 赋值 buffer 缓冲区 comment 注释 curly brace 花括号 parameter 参数 A parameter is a variable in a method definition. argument 实参 Arguments are the data you pass into the method’s parameters. "}]